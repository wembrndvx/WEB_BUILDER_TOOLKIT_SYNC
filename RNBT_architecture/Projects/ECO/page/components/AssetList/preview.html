<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AssetList Preview</title>
    <!-- External Dependencies -->
    <link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
    <script src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
    <!-- Component CSS -->
    <link rel="stylesheet" href="styles/component.css">
    <style>
        /* Reset & Base */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f1219;
            padding: 32px;
        }
    </style>
</head>
<body>
    <!-- 컨테이너 ID: #asset-list-container -->
    <div id="asset-list-container">
        <!-- views/component.html 내용 -->
        <div class="asset-list-panel">
            <div class="panel-header">
                <h2 class="panel-title">Asset List</h2>
                <button class="refresh-btn" title="Refresh">↻</button>
            </div>

            <div class="panel-body split-layout">
                <!-- Tree Pane -->
                <div class="tree-pane">
                    <div class="tree-header">
                        <span class="tree-title">ECO 자산 관리</span>
                        <div class="tree-controls">
                            <button class="btn-expand-all" title="Expand All">+</button>
                            <button class="btn-collapse-all" title="Collapse All">−</button>
                        </div>
                    </div>
                    <div class="tree-search">
                        <input type="text" class="tree-search-input" placeholder="Search tree...">
                    </div>
                    <div class="tree-container">
                        <ul class="tree-root"></ul>
                    </div>
                </div>

                <!-- Resizer -->
                <div class="pane-resizer"></div>

                <!-- Table Pane -->
                <div class="table-pane">
                    <div class="selected-node-info">
                        <span class="node-path">Select a location from the tree</span>
                        <span class="node-count"></span>
                    </div>

                    <div class="toolbar">
                        <div class="search-box">
                            <input type="text" class="search-input" placeholder="Search by name or ID...">
                        </div>

                        <div class="filter-box">
                            <select class="type-filter">
                                <option value="all">All Types</option>
                                <option value="server">Server</option>
                                <option value="rack">Rack</option>
                                <option value="pdu">PDU</option>
                                <option value="ups">UPS</option>
                                <option value="crac">CRAC</option>
                                <option value="sensor">Sensor</option>
                                <option value="switch">Switch</option>
                                <option value="router">Router</option>
                                <option value="storage">Storage</option>
                                <option value="cabinet">Cabinet</option>
                                <option value="circuit">Circuit</option>
                            </select>

                            <select class="status-filter">
                                <option value="all">All Status</option>
                                <option value="normal">Normal</option>
                                <option value="warning">Warning</option>
                                <option value="critical">Critical</option>
                            </select>
                        </div>
                    </div>

                    <div class="table-container"></div>
                </div>
            </div>

            <div class="panel-footer">
                <div class="legend">
                    <span class="legend-item"><span class="dot normal"></span> Normal</span>
                    <span class="legend-item"><span class="dot warning"></span> Warning</span>
                    <span class="legend-item"><span class="dot critical"></span> Critical</span>
                </div>
                <div class="asset-count">
                    <span class="count-label">Total:</span>
                    <span class="count-value">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Mock Data (모든 것이 자산) -->
    <script>
        /**
         * 핵심 원칙: 모든 것은 자산(Asset)
         * - canHaveChildren: true → Tree에 표시 (컨테이너)
         * - canHaveChildren: false → Table에만 표시 (말단)
         * - 자산은 개별로 존재하거나 다른 자산에 포함될 수 있음
         *
         * 다양한 케이스:
         * 1. Building > Floor > Room (공간 계층)
         * 2. Room > Rack > Server (장비 계층)
         * 3. Room > PDU (개별 존재)
         * 4. Rack > PDU (포함 관계)
         * 5. PDU > Circuit (PDU가 컨테이너)
         */

        const randomStatus = () => ['normal', 'normal', 'normal', 'warning', 'critical'][Math.floor(Math.random() * 5)];

        // 전체 계층 구조 (서버 내부 데이터)
        const FULL_HIERARCHY = {
            title: "ECO 자산 관리",
            items: [
                // ========================================
                // 케이스 1: 본관 - 전통적인 공간 계층
                // Building > Floor > Room > Rack > Server
                // ========================================
                {
                    id: "building-001", name: "본관", type: "building",
                    canHaveChildren: true, parentId: null, status: "warning",
                    children: [
                        {
                            id: "floor-001-01", name: "1층", type: "floor",
                            canHaveChildren: true, parentId: "building-001", status: "warning",
                            children: [
                                {
                                    id: "room-001-01-01", name: "서버실 A", type: "room",
                                    canHaveChildren: true, parentId: "floor-001-01", status: "warning",
                                    children: [
                                        // Rack은 컨테이너 (Server를 포함)
                                        {
                                            id: "rack-001", name: "Rack A-01", type: "rack",
                                            canHaveChildren: true, parentId: "room-001-01-01", status: "normal",
                                            children: [
                                                { id: "server-001", name: "Server 001", type: "server", canHaveChildren: false, parentId: "rack-001", status: randomStatus() },
                                                { id: "server-002", name: "Server 002", type: "server", canHaveChildren: false, parentId: "rack-001", status: randomStatus() },
                                                { id: "server-003", name: "Server 003", type: "server", canHaveChildren: false, parentId: "rack-001", status: randomStatus() }
                                            ]
                                        },
                                        {
                                            id: "rack-002", name: "Rack A-02", type: "rack",
                                            canHaveChildren: true, parentId: "room-001-01-01", status: "warning",
                                            children: [
                                                { id: "server-004", name: "Server 004", type: "server", canHaveChildren: false, parentId: "rack-002", status: randomStatus() },
                                                { id: "server-005", name: "Server 005", type: "server", canHaveChildren: false, parentId: "rack-002", status: randomStatus() },
                                                // PDU가 Rack 안에 포함된 케이스
                                                { id: "pdu-001", name: "PDU 001 (In-Rack)", type: "pdu", canHaveChildren: false, parentId: "rack-002", status: randomStatus() }
                                            ]
                                        },
                                        // PDU가 Room에 직접 존재하는 케이스 (Rack 밖)
                                        { id: "pdu-002", name: "PDU 002 (Standalone)", type: "pdu", canHaveChildren: false, parentId: "room-001-01-01", status: randomStatus() },
                                        // CRAC, Sensor는 말단 자산
                                        { id: "crac-001", name: "CRAC 001", type: "crac", canHaveChildren: false, parentId: "room-001-01-01", status: randomStatus() },
                                        { id: "sensor-001", name: "Sensor 001", type: "sensor", canHaveChildren: false, parentId: "room-001-01-01", status: randomStatus() }
                                    ]
                                },
                                {
                                    id: "room-001-01-02", name: "네트워크실", type: "room",
                                    canHaveChildren: true, parentId: "floor-001-01", status: "normal",
                                    children: [
                                        // 네트워크 장비 전용 Rack
                                        {
                                            id: "rack-003", name: "Network Rack 01", type: "rack",
                                            canHaveChildren: true, parentId: "room-001-01-02", status: "normal",
                                            children: [
                                                { id: "switch-001", name: "Switch 001", type: "switch", canHaveChildren: false, parentId: "rack-003", status: randomStatus() },
                                                { id: "switch-002", name: "Switch 002", type: "switch", canHaveChildren: false, parentId: "rack-003", status: randomStatus() },
                                                { id: "router-001", name: "Router 001", type: "router", canHaveChildren: false, parentId: "rack-003", status: randomStatus() }
                                            ]
                                        },
                                        { id: "ups-001", name: "UPS 001", type: "ups", canHaveChildren: false, parentId: "room-001-01-02", status: randomStatus() },
                                        { id: "sensor-002", name: "Sensor 002", type: "sensor", canHaveChildren: false, parentId: "room-001-01-02", status: randomStatus() }
                                    ]
                                }
                            ]
                        },
                        {
                            id: "floor-001-02", name: "2층", type: "floor",
                            canHaveChildren: true, parentId: "building-001", status: "normal",
                            children: [
                                {
                                    id: "room-001-02-01", name: "UPS실", type: "room",
                                    canHaveChildren: true, parentId: "floor-001-02", status: "normal",
                                    children: [
                                        // UPS는 말단 자산 (다른 것을 포함하지 않음)
                                        { id: "ups-002", name: "UPS 002", type: "ups", canHaveChildren: false, parentId: "room-001-02-01", status: randomStatus() },
                                        { id: "ups-003", name: "UPS 003", type: "ups", canHaveChildren: false, parentId: "room-001-02-01", status: randomStatus() },
                                        { id: "ups-004", name: "UPS 004", type: "ups", canHaveChildren: false, parentId: "room-001-02-01", status: randomStatus() },
                                        { id: "sensor-003", name: "Sensor 003", type: "sensor", canHaveChildren: false, parentId: "room-001-02-01", status: randomStatus() }
                                    ]
                                }
                            ]
                        }
                    ]
                },

                // ========================================
                // 케이스 2: 별관 A - PDU가 컨테이너 역할
                // Room > PDU > Circuit (PDU가 회로를 포함)
                // ========================================
                {
                    id: "building-002", name: "별관 A", type: "building",
                    canHaveChildren: true, parentId: null, status: "critical",
                    children: [
                        {
                            id: "floor-002-01", name: "1층", type: "floor",
                            canHaveChildren: true, parentId: "building-002", status: "critical",
                            children: [
                                {
                                    id: "room-002-01-01", name: "전산실", type: "room",
                                    canHaveChildren: true, parentId: "floor-002-01", status: "critical",
                                    children: [
                                        // PDU가 컨테이너 역할 (회로/분기를 포함)
                                        {
                                            id: "pdu-003", name: "PDU 003 (Main)", type: "pdu",
                                            canHaveChildren: true, parentId: "room-002-01-01", status: "warning",
                                            children: [
                                                { id: "circuit-001", name: "Circuit A1", type: "circuit", canHaveChildren: false, parentId: "pdu-003", status: randomStatus() },
                                                { id: "circuit-002", name: "Circuit A2", type: "circuit", canHaveChildren: false, parentId: "pdu-003", status: randomStatus() },
                                                { id: "circuit-003", name: "Circuit B1", type: "circuit", canHaveChildren: false, parentId: "pdu-003", status: randomStatus() }
                                            ]
                                        },
                                        // 일반 PDU (말단)
                                        { id: "pdu-004", name: "PDU 004", type: "pdu", canHaveChildren: false, parentId: "room-002-01-01", status: randomStatus() },
                                        { id: "crac-002", name: "CRAC 002", type: "crac", canHaveChildren: false, parentId: "room-002-01-01", status: "critical" }
                                    ]
                                },
                                {
                                    id: "room-002-01-02", name: "항온항습실", type: "room",
                                    canHaveChildren: true, parentId: "floor-002-01", status: "normal",
                                    children: [
                                        { id: "crac-003", name: "CRAC 003", type: "crac", canHaveChildren: false, parentId: "room-002-01-02", status: randomStatus() },
                                        { id: "crac-004", name: "CRAC 004", type: "crac", canHaveChildren: false, parentId: "room-002-01-02", status: randomStatus() },
                                        { id: "sensor-004", name: "Sensor 004", type: "sensor", canHaveChildren: false, parentId: "room-002-01-02", status: randomStatus() },
                                        { id: "sensor-005", name: "Sensor 005", type: "sensor", canHaveChildren: false, parentId: "room-002-01-02", status: randomStatus() }
                                    ]
                                }
                            ]
                        }
                    ]
                },

                // ========================================
                // 케이스 3: 별관 B - 혼합 구조
                // 깊은 계층 + 빈 컨테이너
                // ========================================
                {
                    id: "building-003", name: "별관 B", type: "building",
                    canHaveChildren: true, parentId: null, status: "normal",
                    children: [
                        {
                            id: "floor-003-01", name: "1층", type: "floor",
                            canHaveChildren: true, parentId: "building-003", status: "normal",
                            children: [
                                {
                                    id: "room-003-01-01", name: "통합관제실", type: "room",
                                    canHaveChildren: true, parentId: "floor-003-01", status: "normal",
                                    children: [
                                        // 캐비넷(컨테이너) 안에 여러 장비
                                        {
                                            id: "cabinet-001", name: "Cabinet 001", type: "cabinet",
                                            canHaveChildren: true, parentId: "room-003-01-01", status: "normal",
                                            children: [
                                                { id: "server-006", name: "Server 006", type: "server", canHaveChildren: false, parentId: "cabinet-001", status: randomStatus() },
                                                { id: "storage-001", name: "Storage 001", type: "storage", canHaveChildren: false, parentId: "cabinet-001", status: randomStatus() },
                                                { id: "pdu-005", name: "PDU 005", type: "pdu", canHaveChildren: false, parentId: "cabinet-001", status: randomStatus() }
                                            ]
                                        },
                                        // 독립 센서들
                                        { id: "sensor-006", name: "Temp Sensor", type: "sensor", canHaveChildren: false, parentId: "room-003-01-01", status: randomStatus() },
                                        { id: "sensor-007", name: "Humidity Sensor", type: "sensor", canHaveChildren: false, parentId: "room-003-01-01", status: randomStatus() },
                                        { id: "sensor-008", name: "Power Meter", type: "sensor", canHaveChildren: false, parentId: "room-003-01-01", status: randomStatus() }
                                    ]
                                }
                            ]
                        },
                        {
                            // 빈 층 (하위 자산 없음, 하지만 canHaveChildren=true)
                            id: "floor-003-02", name: "2층 (비어있음)", type: "floor",
                            canHaveChildren: true, parentId: "building-003", status: "normal",
                            children: []
                        }
                    ]
                }
            ]
        };

        // hasChildren 필드 자동 계산 (children 배열 기반)
        function addHasChildren(items) {
            if (!items) return;
            items.forEach(item => {
                // 컨테이너 children만 카운트 (Tree 표시용)
                const containerChildren = (item.children || []).filter(c => c.canHaveChildren);
                item.hasChildren = containerChildren.length > 0;
                if (item.children) addHasChildren(item.children);
            });
        }
        addHasChildren(FULL_HIERARCHY.items);

        /**
         * depth 제한된 트리 반환 (API 시뮬레이션)
         * - canHaveChildren: true인 노드만 Tree에 포함
         * @param {number} maxDepth - 최대 depth (기본: 2)
         */
        function getHierarchyWithDepth(maxDepth = 2) {
            function limitDepth(items, currentDepth = 1) {
                if (!items) return [];

                // 컨테이너만 필터링
                return items
                    .filter(item => item.canHaveChildren)
                    .map(item => {
                        const containerChildren = (item.children || []).filter(c => c.canHaveChildren);

                        const result = {
                            id: item.id,
                            name: item.name,
                            type: item.type,
                            canHaveChildren: item.canHaveChildren,
                            hasChildren: containerChildren.length > 0,
                            parentId: item.parentId,
                            status: item.status,
                            childCount: (item.children || []).length
                        };

                        if (currentDepth < maxDepth && containerChildren.length > 0) {
                            result.children = limitDepth(containerChildren, currentDepth + 1);
                        } else {
                            result.children = [];
                        }
                        return result;
                    });
            }

            return {
                title: FULL_HIERARCHY.title,
                items: limitDepth(FULL_HIERARCHY.items),
                summary: { depth: maxDepth }
            };
        }

        /**
         * 특정 노드의 직속 컨테이너 children 반환 (Lazy Loading API 시뮬레이션)
         * @param {string} nodeId - 부모 노드 ID
         */
        function getNodeChildren(nodeId) {
            const node = findNodeInHierarchy(FULL_HIERARCHY.items, nodeId);
            if (!node || !node.children) return { parentId: nodeId, children: [] };

            // 컨테이너만 반환
            const containerChildren = node.children
                .filter(child => child.canHaveChildren)
                .map(child => {
                    const subContainers = (child.children || []).filter(c => c.canHaveChildren);
                    return {
                        id: child.id,
                        name: child.name,
                        type: child.type,
                        canHaveChildren: child.canHaveChildren,
                        hasChildren: subContainers.length > 0,
                        parentId: nodeId,
                        status: child.status,
                        childCount: (child.children || []).length
                    };
                });

            return { parentId: nodeId, children: containerChildren };
        }

        // MOCK_DATA (Lazy Loading 테스트: depth=1)
        const MOCK_DATA = {
            get hierarchy() {
                return getHierarchyWithDepth(1);
            }
        };

        /**
         * 노드 하위의 모든 자산 조회 (Table용)
         * - canHaveChildren 관계없이 모든 하위 자산 반환
         * @param {string} nodeId - 부모 노드 ID
         */
        function getAssetsForNode(nodeId) {
            const node = findNodeInHierarchy(FULL_HIERARCHY.items, nodeId);
            if (!node) return [];

            const assets = [];

            function collectAssets(item) {
                // 현재 노드도 자산으로 포함 (루트 노드 제외)
                if (item.id !== nodeId) {
                    assets.push({
                        id: item.id,
                        name: item.name,
                        type: item.type,
                        parentId: item.parentId,
                        canHaveChildren: item.canHaveChildren,
                        status: item.status
                    });
                }
                // 하위 자산 재귀 수집
                if (item.children && item.children.length > 0) {
                    item.children.forEach(child => collectAssets(child));
                }
            }

            collectAssets(node);
            return assets;
        }

        // 계층에서 노드 찾기
        function findNodeInHierarchy(items, targetId) {
            for (const item of items || []) {
                if (item.id === targetId) return item;
                if (item.children) {
                    const found = findNodeInHierarchy(item.children, targetId);
                    if (found) return found;
                }
            }
            return null;
        }
    </script>

    <!-- Render Test -->
    <script>
        const container = document.getElementById('asset-list-container');
        const panel = container.querySelector('.asset-list-panel');

        // State
        let treeData = null;
        let expandedNodes = new Set();
        let loadedNodes = new Set(); // Lazy Loading된 노드 추적
        let selectedNodeId = null;
        let allAssets = [];
        let searchTerm = '';
        let treeSearchTerm = '';
        let typeFilter = 'all';
        let statusFilter = 'all';
        let tableInstance = null;

        // ==================
        // TREE RENDERING
        // ==================

        function renderTree(data) {
            treeData = data.items;
            const titleEl = panel.querySelector('.tree-title');
            if (titleEl) titleEl.textContent = data.title;

            renderTreeNodes(treeData, treeSearchTerm);
            console.log('[Preview] Tree rendered:', data.summary);
        }

        function renderTreeNodes(items, searchTerm = '') {
            const rootEl = panel.querySelector('.tree-root');
            if (!rootEl) return;

            rootEl.innerHTML = '';
            const normalized = searchTerm.toLowerCase().trim();

            items.forEach(item => {
                const nodeEl = createTreeNode(item, normalized);
                if (nodeEl) rootEl.appendChild(nodeEl);
            });
        }

        function createTreeNode(item, searchTerm) {
            const { id, name, type, status, children = [], hasChildren: apiHasChildren, assetCount } = item;
            // hasChildren: API에서 제공된 값이 있으면 사용, 없으면 children 배열로 판단
            const hasChildren = apiHasChildren !== undefined ? apiHasChildren : children.length > 0;
            const hasLoadedChildren = children.length > 0;
            const isExpanded = expandedNodes.has(id);
            const isSelected = selectedNodeId === id;
            const needsLazyLoad = hasChildren && !hasLoadedChildren && !loadedNodes.has(id);

            const matchesSearch = !searchTerm || name.toLowerCase().includes(searchTerm);
            const hasMatchingDescendants = hasLoadedChildren && checkDescendants(children, searchTerm);

            if (searchTerm && !matchesSearch && !hasMatchingDescendants) return null;

            const li = document.createElement('li');
            li.className = 'tree-node';
            li.dataset.nodeId = id;
            li.dataset.nodeType = type;
            li.dataset.hasChildren = hasChildren;
            li.dataset.needsLazyLoad = needsLazyLoad;

            const content = document.createElement('div');
            content.className = 'node-content';
            if (isSelected) content.classList.add('selected');

            const toggle = document.createElement('span');
            toggle.className = 'node-toggle';
            if (hasChildren) {
                toggle.textContent = '▶';
                if (isExpanded) toggle.classList.add('expanded');
            } else {
                toggle.classList.add('leaf');
            }

            const icon = document.createElement('span');
            icon.className = 'node-icon';
            icon.dataset.type = type;

            const label = document.createElement('span');
            label.className = 'node-label';
            label.textContent = name;

            content.appendChild(toggle);
            content.appendChild(icon);
            content.appendChild(label);

            if (type === 'room' && assetCount !== undefined) {
                const count = document.createElement('span');
                count.className = 'node-asset-count';
                count.textContent = `(${assetCount})`;
                content.appendChild(count);
            }

            const statusDot = document.createElement('span');
            statusDot.className = `node-status ${status}`;
            content.appendChild(statusDot);

            li.appendChild(content);

            if (hasChildren) {
                const childrenUl = document.createElement('ul');
                childrenUl.className = 'node-children';
                if (isExpanded || (searchTerm && hasMatchingDescendants)) {
                    childrenUl.classList.add('expanded');
                }

                if (hasLoadedChildren) {
                    children.forEach(child => {
                        const childEl = createTreeNode(child, searchTerm);
                        if (childEl) childrenUl.appendChild(childEl);
                    });
                } else if (needsLazyLoad) {
                    // Lazy Loading 필요한 경우 로딩 표시
                    const loadingLi = document.createElement('li');
                    loadingLi.className = 'tree-node loading-placeholder';
                    loadingLi.innerHTML = '<span class="loading-text">Loading...</span>';
                    childrenUl.appendChild(loadingLi);
                }

                li.appendChild(childrenUl);
            }

            return li;
        }

        function checkDescendants(children, searchTerm) {
            if (!searchTerm) return false;
            return children.some(child => {
                if (child.name.toLowerCase().includes(searchTerm)) return true;
                return child.children && checkDescendants(child.children, searchTerm);
            });
        }

        // ==================
        // NODE ACTIONS
        // ==================

        function toggleNode(nodeId, nodeEl) {
            const isExpanding = !expandedNodes.has(nodeId);

            if (isExpanding) {
                expandedNodes.add(nodeId);

                // Lazy Loading 필요 여부 확인
                const needsLazyLoad = nodeEl?.dataset.needsLazyLoad === 'true';

                if (needsLazyLoad && !loadedNodes.has(nodeId)) {
                    // Lazy Loading 시뮬레이션 (500ms 지연)
                    console.log(`[Preview] Lazy loading children for ${nodeId}...`);

                    setTimeout(() => {
                        const data = getNodeChildren(nodeId);
                        appendChildren(data);
                    }, 500);
                }
            } else {
                expandedNodes.delete(nodeId);
            }

            updateNodeVisuals(nodeId);
        }

        /**
         * Lazy Loading으로 가져온 children을 트리에 추가
         */
        function appendChildren(data) {
            if (!data || !data.parentId) return;

            const { parentId, children } = data;

            // 트리 데이터에 children 추가
            addChildrenToNode(treeData, parentId, children);

            // 로딩 완료 표시
            loadedNodes.add(parentId);

            // 트리 재렌더링
            renderTreeNodes(treeData, treeSearchTerm);

            console.log(`[Preview] Lazy loaded ${children.length} children for ${parentId}`);
        }

        /**
         * 트리 데이터에서 특정 노드를 찾아 children 추가
         */
        function addChildrenToNode(items, parentId, children) {
            if (!items) return false;

            for (const item of items) {
                if (item.id === parentId) {
                    item.children = children;
                    return true;
                }
                if (item.children && item.children.length > 0) {
                    if (addChildrenToNode(item.children, parentId, children)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function selectNode(nodeId) {
            const prev = panel.querySelector('.node-content.selected');
            if (prev) prev.classList.remove('selected');

            selectedNodeId = nodeId;

            const nodeEl = panel.querySelector(`[data-node-id="${nodeId}"] > .node-content`);
            if (nodeEl) nodeEl.classList.add('selected');

            // 노드 경로 찾기
            const nodePath = getNodePath(MOCK_DATA.hierarchy.items, nodeId);
            const assets = getAssetsForNode(nodeId);

            renderTable({ nodePath, assets });
            console.log('[Preview] Node selected:', nodeId);
        }

        function getNodePath(items, targetId, path = []) {
            for (const item of items || []) {
                const currentPath = [...path, item.name];
                if (item.id === targetId) return currentPath.join(' > ');
                if (item.children) {
                    const found = getNodePath(item.children, targetId, currentPath);
                    if (found) return found;
                }
            }
            return null;
        }

        function expandAll() {
            collectAllNodeIds(treeData);
            renderTreeNodes(treeData, treeSearchTerm);
        }

        function collapseAll() {
            expandedNodes.clear();
            renderTreeNodes(treeData, treeSearchTerm);
        }

        function collectAllNodeIds(items) {
            if (!items) return;
            items.forEach(item => {
                if (item.children && item.children.length > 0) {
                    expandedNodes.add(item.id);
                    collectAllNodeIds(item.children);
                }
            });
        }

        function updateNodeVisuals(nodeId) {
            const nodeEl = panel.querySelector(`[data-node-id="${nodeId}"]`);
            if (!nodeEl) return;

            const toggle = nodeEl.querySelector(':scope > .node-content > .node-toggle');
            const children = nodeEl.querySelector(':scope > .node-children');
            const isExpanded = expandedNodes.has(nodeId);

            if (toggle) toggle.classList.toggle('expanded', isExpanded);
            if (children) children.classList.toggle('expanded', isExpanded);
        }

        // ==================
        // TABLE RENDERING
        // ==================

        function renderTable(data) {
            const { nodePath, assets = [] } = data;

            const pathEl = panel.querySelector('.node-path');
            const countEl = panel.querySelector('.selected-node-info .node-count');
            if (pathEl) pathEl.textContent = nodePath || '전체 자산';
            if (countEl) countEl.textContent = `${assets.length}개`;

            allAssets = assets;
            applyFilters();

            console.log('[Preview] Table rendered:', assets.length, 'assets');
        }

        function applyFilters() {
            const search = searchTerm.toLowerCase();

            const filtered = allAssets.filter(asset => {
                const matchesSearch = !search ||
                    asset.name.toLowerCase().includes(search) ||
                    asset.id.toLowerCase().includes(search);
                const matchesType = typeFilter === 'all' || asset.type === typeFilter;
                const matchesStatus = statusFilter === 'all' || asset.status === statusFilter;
                return matchesSearch && matchesType && matchesStatus;
            });

            if (tableInstance) {
                tableInstance.setData(filtered);
            }

            const countEl = panel.querySelector('.count-value');
            if (countEl) countEl.textContent = filtered.length;
        }

        // ==================
        // TABLE INIT
        // ==================

        function initTable() {
            const container = panel.querySelector('.table-container');
            if (!container) return;

            container.id = 'asset-table';

            tableInstance = new Tabulator('#asset-table', {
                layout: 'fitColumns',
                height: 350,
                placeholder: 'Select a location from the tree',
                selectable: 1,
                columns: [
                    { title: 'ID', field: 'id', widthGrow: 1, headerSort: true },
                    { title: 'Name', field: 'name', widthGrow: 2, headerSort: true },
                    {
                        title: 'Type', field: 'type', widthGrow: 1, headerSort: true,
                        formatter: cell => `<span class="type-badge" data-type="${cell.getValue()}">${cell.getValue().toUpperCase()}</span>`
                    },
                    {
                        title: 'Status', field: 'status', widthGrow: 1, headerSort: true,
                        formatter: cell => `<span class="status-badge" data-status="${cell.getValue()}">${cell.getValue()}</span>`
                    }
                ]
            });

            tableInstance.on('rowClick', (e, row) => {
                console.log('[Preview] Asset selected:', row.getData());
            });
        }

        // ==================
        // RESIZER
        // ==================

        function setupResizer() {
            const resizer = panel.querySelector('.pane-resizer');
            const treePane = panel.querySelector('.tree-pane');
            if (!resizer || !treePane) return;

            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = treePane.offsetWidth;
                resizer.classList.add('dragging');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                e.preventDefault();
            });

            function onMouseMove(e) {
                if (!isResizing) return;
                const diff = e.clientX - startX;
                const newWidth = Math.min(400, Math.max(200, startWidth + diff));
                treePane.style.width = `${newWidth}px`;
            }

            function onMouseUp() {
                isResizing = false;
                resizer.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        // ==================
        // EVENT HANDLERS
        // ==================

        function setupEventHandlers() {
            // Tree click (event delegation)
            panel.querySelector('.tree-container')?.addEventListener('click', (e) => {
                const nodeContent = e.target.closest('.node-content');
                if (!nodeContent) return;

                const nodeEl = nodeContent.closest('.tree-node');
                if (!nodeEl) return;

                const nodeId = nodeEl.dataset.nodeId;
                const toggle = nodeContent.querySelector('.node-toggle');

                if (e.target.closest('.node-toggle') && !toggle.classList.contains('leaf')) {
                    toggleNode(nodeId, nodeEl);
                } else {
                    selectNode(nodeId);
                }
            });

            // Tree search
            panel.querySelector('.tree-search-input')?.addEventListener('input', (e) => {
                treeSearchTerm = e.target.value;
                if (treeData) renderTreeNodes(treeData, treeSearchTerm);
            });

            // Expand/Collapse buttons
            panel.querySelector('.btn-expand-all')?.addEventListener('click', expandAll);
            panel.querySelector('.btn-collapse-all')?.addEventListener('click', collapseAll);

            // Table search
            panel.querySelector('.search-input')?.addEventListener('input', (e) => {
                searchTerm = e.target.value;
                applyFilters();
            });

            // Type filter
            panel.querySelector('.type-filter')?.addEventListener('change', (e) => {
                typeFilter = e.target.value;
                applyFilters();
            });

            // Status filter
            panel.querySelector('.status-filter')?.addEventListener('change', (e) => {
                statusFilter = e.target.value;
                applyFilters();
            });

            // Refresh button
            panel.querySelector('.refresh-btn')?.addEventListener('click', () => {
                console.log('[Preview] Refresh clicked');
                renderTree(MOCK_DATA.hierarchy);
            });
        }

        // ==================
        // INIT
        // ==================

        window.onload = () => {
            initTable();
            setupResizer();
            setupEventHandlers();
            renderTree(MOCK_DATA.hierarchy);
        };
    </script>
</body>
</html>
